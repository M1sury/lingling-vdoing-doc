---
title: Redis设计与实现
date: 2022-12-24 15:26:16
permalink: /pages/ee667c/
tags: 
  - null
categories: 
  - 数据库
  - Redis
author: 
  name: lingling
  link: https://github.com/M1sury
---

> 《Redis设计与实现》是基于 Redis 2.9 来编写的
>
> 虽然版本比较老，但是其中的基本功能也是全面的，比较新的版本因为迭代了多项功能之后，反而显得不那么容易理解
>
> 笔记不会逐一把用到的命令都写出来，[redis命令手册](https://www.redis.net.cn/order/)可以查看具体的命令



## 数据结构与对象

**Redis<key,value>数据库里面的每个键值对都是由对象组成。每一个 key 都是一个字符串对象，而 value 可以是字符串、List、哈希、set、zSet五种对象中的一种**

### SDS

> SDS(Simple Dynamic Strings) 意思就是简单动态字符串，Redis中的字符串数据结构并不是直接使用的C语言的

```c
struct sdshdr{
    // 记录buf数组中已经使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字符数组，用于保存字符串
    char buf[];
}
```

> 以一个存储"Redis"的字符串对象举例
>
> free = 0，表示这个SDS没有分配任何未使用空间
>
> len = 5，表示这个SDS保存了一个五字节长度的字符串
>
> buf 就是存放对应要存储的数据
>
> 而`\0`不用多说，是遵循C字符串的通用结尾。**并且保存`\0`的最后一个字节是不计算在SDS的len属性中
>
> 遵循`\0`结尾的好处是：SDS可以直接重用一部分C字符串函数库里面的函数,比如`printf()`

![image-20220703165210274](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220703165210274.png)

#### SDS与C字符串的区别

C字符串的传统，是使用长度为 N+1 的字符数组来表示长度为 N 的字符串，并且数组的最后一个元素总是`\0`

**但是，C语言使用这样简单的字符串数据结构，不能满足 Redis 对字符串在安全性、效率以及功能方面的要求**。原因主要是通过以下几点来证明 SDS 比C字符串更适用于Redis

1. **常数复杂度获取字符串长度**

因为C字符串不会记录自身的长度信息，所以如果要获取字符串的长度，必须要遍历整个字符串进行计数。这种方法的时间复杂度是`O(n)`

而 SDS 在len属性中记录了 SDS 本身的长度，所以获取一个 SDS 长度的复杂度只有 `O(1)`

通过使用 SDS 而不是C字符串，Redis将获取字符串长度所需的复杂度降到O(1)。确保获取字符串长度的工作不会成为 Redis 的性能瓶颈

2. **杜绝缓冲区溢出**

C字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出

```c
char *stract(char *dest,const char *src)
```

比如使用C字符串的拼接函数，因为C字符串不记录自身长度，所以拼接的时候不会判断`dest`字符串的内存是否足够。

假设内存中有两个紧邻的C字符串 s1(存储Redis) 和 s2(存储MongoDB)，如果需要对 s1 变成 "Redis Cluster"。但是并没有给 s1 分配足够的空间，s2 的内容就会被 s1 增加的内容所覆盖

> 修改前

![image-20220703174709553](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220703174709553.png)

> 修改后

![image-20220703174932993](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220703174932993.png)

**而 SDS 的空间分配策略就是在 C的基础上优化：要对SDS进行修改时，会先检查 SDS 的空间是否满足修改的要求，如果空间不够，会自动为SDS的空间扩展到修改所需要的大小，然后才进行修改。**

#### 减少修改字符串的内存重分配次数

C字符串不记录自身长度，所以 C字符串的底层实现总是一个 N+1 个字符长的数组。所以每次增长和缩短一个C字符串，程序都要对保存这个C字符串的数组进行一次内存重分配的工作

* 如果执行的是长度增长的操作，在执行操作之前，需要先通过内存重分配来扩展底层数组的空间大小，**如果忘了这一步就会产生缓冲区溢出**
* 如果执行的是长度缩短的操作，在执行操作前，需要通过内存重分配来释放字符串不再使用的部分，**如果忘了这一步就会产生内存泄漏**

因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以可以理解为是一个比较耗时的操作。**Redis作为一个内存数据库，经常被用于速度要求严格、数据被频繁修改的场景，如果每次都要进行比较耗时的操作，是很影响性能的**

为了避免C字符串的缺陷，SDS 通过未使用空间(free属性) 来解决这种缺陷

* **空间预分配：**用于优化 SDS 的长度增长操作，当 API 对一个SDS进行长度增长的操作。**程序不仅会为 SDS 分配修改所必须要的空间，还会分配额外的未使用空间**

  * 如果对 SDS 进行修改之后， SDS 的长度小于`1MB`，程序分配和 `len`属性同样大小的未使用空间，这时 SDS 的 `len == free`。

  ![image-20220703182628417](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220703182628417.png)

  * 如果对 SDS 进行修改之后，SDS的长度大于等于 `1MB`，程序会分配 1MB 的未使用空间，**如果一个 SDS 修改之后 len 变成 30MB，程序会分配 1MB的未使用空间，SDS的 buf数组的实际长度：`30MB + 1MB + 1byte`

  **通过空间预分配策略，Redis可以减少连续执行字符串增长操作需要的内存重分配次数**

* **惰性空间释放：**用于优化 SDS 的字符串缩短操作。当 SDS 需要缩短保存的字符串，程序不会立刻使用内存重分配回收缩短后多出来的字节，而是用 free属性把这些多出来的字节的数量记录起来，等待将来使用

3. **二进制安全**

C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，**不能包含空字符串，否则最先被程序读入的空字符会被误认为字符串结尾**。这种限制就使 C字符串只能保存文本数据，不能保存像图片、音频、视频等二进制数据。就比如 "Red\0is"就会被截开，只会识别 "Red" ，忽略 "is"

Redis为了确保可以适用于各种不同的场景，SDS的API都是二进制安全的，所有SDS的API都会以处理二进制的方式来处理 SDS存放在buf数组里面的数据。不会对数据做限制。**数据写入时是什么样子，被读取的时候就是什么样**

**因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束**。这就保证了Redis不仅可以存储文本数据，也可以保存任意格式的二进制数据

**并且SDS 也会 兼容部分 C字符串的函数，因为虽然SDS 是 二进制安全，但是他们都一样遵循 C字符串以空字符结尾的惯例**



### 链表

> 链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活调整链表长度

#### 链表和链表节点的实现

```c
// 每个链表节点使用一个listNode结构表示
typedef struct listNode{
    //前置节点
    struct listNode * prev;
    //后置节点
    struct listNode * next;
    // 节点值
    void * value;
}listNode;
```

**多个 listNode 可以通过 prev 和 next 指针组成双端链表**

> 虽然用多个 listNode 结构就可以组成链表，但使用 list来持有链表，会更方便

```c
typedef struct list{
    // 表头节点 
    listNode * head;
    // 表尾节点
    listNode * tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void *(*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr,void *key);
}list;
```

> 由一个list结构和三个listNode结构组成的链表

![image-20220704210127479](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220704210127479.png)

#### 特性

* 双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的复杂度都是 O(1)
* 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点
* 带头节点和尾节点： 通过 list 结构的 head 指针和 tail 指针，程序获取链表的头节点和尾节点的复杂度都是 O(1)
* 带链表长度计算器：程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数，获取链表长度的复杂度是 O(1)
* 多态：链表可以保存各种不同类型的值

### 字典

> 字典，是一种用于保存键值对的抽象数据结构。类似于 Java 中的 Map

字典的每个键都是独一无二的，可以通过键查找关联的值，也可以通过键进行更新值或者删除键值对

字典经常作为一种数据结构内置在很多高级编程语言中，但是C 语言中没有内置这种数据结构，所以 Redis 编写了自己的字段实现

字典在 Redis 中的应用相当广泛，比如 Redis 的数据库就是用字段作为底层实现。对Redis 的增删改查也是在对字典的操作之上的。

#### 字典的实现

Redis 的字典用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，每个哈希表节点保存字典中的一个键值对

```c
typedef struct dictht{
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码,用于计算索引值，总是等于size-1
    unsigned long sizemark;
    // 该哈希表已有节点的数量给
    unsigned long used;
}dictht;
```

table 是一个数组，每个元素都是 dictEntry，每个 dictEntry 结构保存着一个键值对，size 记录哈希表的大小，也是table数组的大小，used记录哈希表内已有的键值对数量，sizemark 的值总是 size-1,与哈希值一起决定一个键应该被放到 table 数组的哪个索引上

```c
typedef struct dictEntry{
    // 键
    void *key;
    // 值,可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    // 指向下个哈希表节点，形成链表
}
```

next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值一样的简直对连接在一起，解决键冲突的问题(**PS：设计可以参考 Java 的 HashMap，如出一辙**)

![image-20220704213150703](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220704213150703.png)

```c
typedef struct dict{
    // 类型特定函数,为多态而设计
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash索引
    // 当rehash不在进行时，值为-1
    int rehashidx;
}
```

ht 属性是一个包含两个项的数组，数组的每一个元素都是一个 dictht 哈希表，一般情况下，字段只使用 ht[0] 哈希表，ht[1]哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。**还有一个和 rehash 有关的属性就是 rehashidx**，记录了 rehash 目前的进度，如果当前没有在进行 rehash 的操作，值为 -1

#### 解决键冲突

Redis 的哈希表使用链地址法来解决键冲突。因为哈希表的键值对没有指向链表表尾的指针，为了速度考虑，总是把新节点添加到链表的表头位置，排在其他已有节点的前面（**PS: JDK1.7中的 HashMap 也是使用头插法的方式来解决键冲突**）

#### rehash

> 随着操作的不断执行，哈希表保存的键值对会逐渐增多或减少，为了让哈希表的负载因子维持在一个合理的范围，当哈希表内的键值对太多或者太少，会对哈希表的大小进行相应扩展或收缩

**扩展和收缩哈希表的工作通过执行 rehash 操作来完成，步骤如下：**

1. 为字典的 ht[1] 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，和ht[0] 当前包含的键值对数量(ht[0].used 属性的值)
   * 如果执行的是扩展操作，ht[1] 的大小是 第一个大于等于 ht[0].used*2 的 2<sup>n</sup>。比如 ht[0].used=10,ht[1].used = `大于等于10*2的2的n次方数`，所以 ht[1].used = 32
   * 如果执行的是收缩操作，ht[1] 的大小等于 ht[0].used的 2n。也就是两倍
2. 将保存在 ht[0]中所有键值对 rehash 到 ht[1] 上面：**rehash指的是重新计算键的哈希值和索引值**，然后将键值对放置到 ht[1] 的指定位置上
3. 当 ht[0] 的键值对都迁移到 ht[1]上，ht[0] 清空，把 ht[1] 设置为 ht[0].在 ht[1] 新建一个空白哈希表，为下次 rehash做准备

##### 哈希表的扩展与收缩

> 当以下条件的任意一个被满足时，程序自动开始对哈希表执行扩展操作
>
> 哈希表的负载因子计算公式： `load_factor = ht[0].used / ht[0].size`。
>
> 负载因子 = 哈希表已保存节点数量  / 哈希表大小，例如：load_factor = 4/4 = 1。

1. 服务器目前没有在执行 BGSAVE 命令或 BGREWRITEAOF 命令，并且哈希表的负载因子 >= 1
2. 服务器目前正在执行 BGSAVE 命令或 BGREWRITEAOF 命令，并且哈希表的负载因子 >= 5

根据 BGSAVE 或 BGREWRITEAOF 命令是否正在执行，服务器执行扩展操作需要的负载因子不一样，是因为执行这两个命令过程中，Redis要创建当前服务器进程的子进程，而大多数 OS 都采用 写时复制 技术来优化子进程的使用效率，在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能避免子进程存在期间进行哈希表扩展操作，可以避免不必要的内存写入，最大限度节约内存(**PS：其实这段并不理解，尤其是 写时复制**)

另一方面，哈希表的负载因子小于 0.1 时，自动开始对哈希表执行收缩操作

#### 渐进式 Rehash

扩展或收缩哈希表需要把 ht[0] 的所有键值对 rehash 到 ht[1] 里面，但是，**这个 rehash 动作并不是一次性、集中式的完成，而是分多次、渐进式地完成的 **

这样做的原因是如果 ht[0] 的键值对少的话，服务器可以在瞬间完成 rehash 操作，但是如果键值对很多，几百万/几千万/几亿，一次性 rehash 到 ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务

> 渐进式 Rehash 的详细步骤：

1. 为 ht[1] 分配空间，让字段同时持有 ht[0] 和 ht[1] 两个哈希表
2. 在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0，表示 rehash 工作正式开始
3. 在 rehash 进行期间，每次对字典的CRUD操作，程序除了执行指定操作外，还会顺带把 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1],当 rehash 工作完成后，程序将 rehashidx 属性加一
4. 当 ht[0] 的所有键值对都被 rehash 到 ht[1],程序将 rehashidx 属性的值设为 -1,表示 rehash 操作完成。

**渐进式 rehash 的好处在于它分而治之的方式，将 rehash 键值对所需的计算工作都均摊在对字典的每个CRUD操作上，避免了集中式 rehash 的庞大计算量**



### 跳跃表

> 跳跃表( skiplist) 是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问的目的
>
> 跳跃表支持平均O(logN)、最坏O(N) 复杂度的节点查找，也可以通过顺序性操作来批量处理节点

大部分情况，跳表的效率与平衡树差不多，并且因为跳表的实现比平衡树简单，所以不少程序用跳表代替平衡树

Redis 使用跳表作为有序集合键的底层实现**之一**，如果一个有序集合包含的数量较多，或者集合中元素的成员是比较长的字符串，Redis 会用跳表作为有序集合键的底层实现



## 单机数据库的实现



## 多机数据库的实现



## 独立功能的实现

